
-- When creating new DB, you've to enable POSTGIS extension. Typing these commands in the query window.

CREATE EXTENSION postgis;
CREATE EXTENSION postgis_topology;

-- creating object id table with unique ID's
-- Unique IDs are generated by using python uuid library
-- there limit is calculated by scanning total number of rows in the trajectory.csv file
create table obj (
	obj_id serial primary key,
	unique_id text
)

-- creating POI table with unique id retrieved from .json files
-- This unique id is provided by google places api
		   
 create table poi(
 	poi_id text primary key, -- this key is fetched from the data retrieved from Google Places API.
 	geom_point geometry -- I'm adding POINT inside the datasets using python script. Just mentioning it as "geometry(POINT, 4326)" doesn't work.
)

-- This statement assigns the srid to geometry column
update poi set geom_point = st_setsrid(geom_point, 4326)  

-- Creating table for trajectory data.

 create table traj (
 	traj_id serial primary key, 
	obj_id integer references obj(obj_id),
 	total_distance text, 
 	travel_time text, 
	traj_path geometry -- Adding LINESTRING in the data column through notepad++
 )
 
-- Assigning SRID to traj_path column.
update traj set traj_path = st_setsrid(traj_path, 4326) 

-- storing grid ids related to different generated grids. 

create table grids (
	grid_id float primary key,
	x_dim integer,
	y_dim integer
)
			
-- From the python code we divide the area into specified grids. Grids are dynamic and can be specified in x & y dimensions i.e. 4x4, 5x6 & 10x7 etc.
-- Storing grid cells

create table cells (
	cell_id serial primary key, -- changed to serial in cell_01
	grid_id float references grids(grid_id),
	cell_names text,
	coordinates geometry -- Creating POLYGON geometry: need to specify first and last coordinate same for each of them. 
)

-- Assigning SRID to coordinates column.
update cells set coordinates = st_setsrid(coordinates, 4326) 

-- Retrieving points that are inside grid cells and associating them. 

-- ST_Within(geometry A , geometry B) returns TRUE if the first geometry is completely within the second geometry.

-- poi cell association table

  
select p.poi_id, c.cell_id, c.grid_id into table poi_cell_association
  from poi p, cells c
  where st_within(p.geom_point, c.coordinates) and grid_id = 216
  
  
-- Checking distance stuff:

SELECT ST_Distance(
		ST_GeomFromText('POINT(43.775502 -79.521692)', 4326),
		ST_GeomFromText('POINT(43.763545 -79.491160)', 4326)
	);

st_distance
0.032 -- which is around 3.2km. 


-- associating trajectories and POIs within 100m distance of each other and storing results in a traj_poi_association table.

	
select t.obj_id, t.traj_id, p.poi_id into table traj_poi_association
	from poi p, traj t 
	where ST_DWithin(t.traj_path, p.geom_point, 0.001) -- 0.001 = 100m
	order by obj_id;
	
-- running inner join from traj_poi_association on traj table to fetch traj paths.

select distinct tp.traj_id, tr.traj_id, st_astext(tr.traj_path) 
 	from traj_poi_association tp
	inner join traj tr on tp.traj_id = tr.traj_id
 	order by tp.traj_id


-- working towards creating traj_cell_association i.e., converting a trajectory from a set of points to a collection of grid cells.	

-- fetching points from trajectory LINESTRING paths. 
SELECT ST_AsText(
   ST_PointN(
	  tr.traj_path,
	  generate_series(1, ST_NPoints(tr.traj_path))
   )) as TrajPoints
into table traj_points
FROM traj tr; 		

-- Got 22494 points out of it.

-- Getting set of trajectories that are inside the grid cells. (it won't be possible to get any results, if grid cells are of smaller size).

select tr.traj_id, st_astext(tr.traj_path), st_astext(ce.coordinates)
 from traj tr, cells ce
 where st_within(tr.traj_path, ce.coordinates) and ce.grid_id = 972
 ORDER by tr.traj_id
 
 
 -- storing traj_path points with their id's. By seeing if those points intersect with trajectory path. And storing only the distinct points.
 
 select distinct st_astext(tp.trajpoints) as traj_points, tr.traj_id as traj_id into table traj_poi_id
	from traj tr, traj_points tp
	where st_intersects(tr.traj_path ::geometry, tp.trajpoints ::geometry)
	order by tr.traj_id

-- Storing traj_id's and the ID's of cells from which they pass through in a table called traj_cell_association.

select tr.traj_id, ce.cell_id into table traj_cell_association
 	from traj_poi_id tr, cells ce
  	where st_within(tr.traj_points, ce.coordinates) and grid_id = 7776


-- getting cell_id's and cell_names for the traj that passes through those cells. 

select distinct tc.cell_id, ce.cell_names 
	from traj_cell_association tc
	inner join cells ce on tc.cell_id = ce.cell_id
	where tc.traj_id = 201	


-- Getting cell_names of the cells from which traj is passing through. We are simply using Postgis query. 
-- Problem with this query is that it can't maintain the order of cells by which trajectory is passing through them.

select ce.cell_names
	from cells ce, traj tr
	where st_intersects(tr.traj_path, ce.coordinates) and tr.traj_id = 207 and ce.grid_id = 7776
	
	
-- Getting cell_names of the cells from which traj is passing through. (Considering single traj id)

SELECT traj_id, cell_id, cell_names
FROM   (
  SELECT tr.traj_id, ce.cell_id, ce.cell_names,
         ST_LineLocatePoint(tr.traj_path, ST_Centroid(ce.coordinates)) AS frac
  FROM   cells AS ce
  JOIN   traj AS tr
    ON   ST_Intersects(ce.coordinates, tr.traj_path)
	where tr.traj_id = 201 and ce.grid_id = 7776
	
) q
ORDER BY
       frac
;

-- Storing traj_id, cell_id, & cell_names inside a table traj_as_cells

SELECT traj_id, cell_id, cell_names into table traj_as_cells
FROM   (
  SELECT tr.traj_id, ce.cell_id, ce.cell_names, ce.grid_id, 
         ST_LineLocatePoint(tr.traj_path, ST_Centroid(ce.coordinates)) AS frac
  FROM   cells AS ce
  JOIN   traj AS tr
    ON   ST_Intersects(ce.coordinates, tr.traj_path)
	where ce.grid_id = 7776
) q
ORDER BY
       frac
; 












		